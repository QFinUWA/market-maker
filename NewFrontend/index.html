<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>QFIN Orderbooks</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <script src="lib/signalr/signalr.js"></script>
    </head>
    <body class="bg-gray-300 w-full">
            <nav class="bg-white shadow p-4 flex justify-between items-center h-[6vh]">
                <div class="flex space-x-6">
                    <h1 id="exchangeName">[Exchange Name]</h1>
                    <h1 id="exchangeCode" class="text-slate-500" >[Exchange Code]</h1>
                </div>
                <div id="exchangeState">[State]</div>
            </nav>

            <div class="mx-auto w-[96vw] mt-[1vh] h-[80vh] shadow-lg">
                <div id="tab-navigation" class="flex h-[4%] min-h-[26px]">
                </div>
            
                <div id="tab-content" class=" h-[96%] w-full">
                </div>
            </div>

        <script>

            let exchange = {
                markets: {}, // dictionary of market codes to dictionary of orders and transactions
                participants: [],
                state: "Lobby",
                exchangeName: "",
                exchangeCode: "",
            };

            const serverURL = "https://market-maker.azurewebsites.net/";
        
            marketToTabID = {} // used to identify the content tab ID for a given market (to use for populating the tab content)


            // updates all the content on the page
            function updateContent() {
                document.getElementById("exchangeName").textContent = exchange.exchangeName;
                document.getElementById("exchangeCode").textContent = exchange.exchangeCode;
                document.getElementById("exchangeState").textContent = exchange.state;
            }

            // generates the tabs for each market (should run every time markets change)
            function generateTabs(tabNames) {
                const tabNavigation = document.getElementById('tab-navigation');
                const tabContent = document.getElementById('tab-content');

                const activeTabColor = "bg-gray-200";
                const inactiveTabColor = "bg-gray-100";
                // Clear existing tabs and content
                tabNavigation.innerHTML = '';
                tabContent.innerHTML = '';
                
                marketToTabID = tabNames.reduce((acc, name, index) => {
                    acc[name] = `content-${index}`; // create a dictionary of market names to tab content IDs
                    return acc;
                }, {});
                // Create tabs and content dynamically
                tabNames.forEach((name, index) => {
                    const tabId = `tab-${index}`;
                    const contentId = `content-${index}`;

                    // Create tab element
                    const tab = document.createElement('div');
                    tab.id = tabId;
                    tab.classList.add('tab', inactiveTabColor, 'hover:'+activeTabColor, 'px-4', 'rounded-t-md', 'cursor-pointer');
                    tab.textContent = name;
                    tabNavigation.appendChild(tab);

                    // Create content element
                    const content = document.createElement('div');
                    content.id = contentId;
                    content.classList.add('p-4', 'bg-gray-200', 'hidden', 'h-full', 'flex', 'rounded-br-lg', 'rounded-bl-lg', 'rounded-tr-lg');
                    tabContent.appendChild(content);

                    // Click handler for tabs
                    tab.addEventListener('click', () => {
                        const allContent = document.querySelectorAll('[id^="content-"]');
                        allContent.forEach(item => item.classList.add('hidden'));
                        document.getElementById(contentId).classList.remove('hidden');
                        const allTabs = document.querySelectorAll('[id^="tab-"]');
                        allTabs.forEach(item => item.classList.remove(activeTabColor));
                        allTabs.forEach(item => item.classList.add(inactiveTabColor));
                        document.getElementById(tabId).classList.remove(inactiveTabColor);
                        document.getElementById(tabId).classList.add(activeTabColor);

                    });
                });

                // Show the first tab initially
                tabNavigation.firstChild.click();

            }



            function bindConnection(jwt) {
                // Thank you Isaac
                // Called when creating a exchange or joining an exchange
                const connection = new signalR.HubConnectionBuilder()
                    .withUrl(serverURL + "exchange", {
                        skipNegotiation: true,
                        transport: signalR.HttpTransportType.WebSockets,
                        accessTokenFactory: () => jwt,
                    })
                    // .configureLogging(signalR.LogLevel.Debug)
                    .build();

                async function start() {
                    try {
                        await connection.start();
                        console.log("SignalR Connected.");
                    } catch (err) {
                        console.log(err);
                        // setTimeout(start, 50000000);
                    }
                }

                connection.onclose(async () => {
                    await start();
                });

                connection.on("ReceiveMessage", (message) => {
                    console.log("server: " + message);
                });

                connection.on("ExchangeState", (exchangeResponse) => {
                    exchangeResponse.orders.forEach((order) => {
                        exchange.markets[order.market].orders.push(order);
                    });
                    exchangeResponse.transactions.forEach((transaction) => {
                        exchange.markets[transaction.market].transactions.push(transaction);
                    });
                    console.log("ExchangeState", exchangeResponse, exchange);
                });

                connection.on("StateUpdated", (newState) => {
                    exchange.state = newState;
                    console.log("StateUpdated", exchange);
                });

                connection.on("LobbyState", (message) => {
                    // for each market, add an empty list to the dictionary
                    message.markets.forEach((market) => {
                        exchange.markets[market[0]] = {"orders": [], "transactions": []}; // each market is a list for some reason
                    });

                    exchange.participants = message.participants;
                    exchange.exchangeName = message.exchangeName;
                    exchange.exchangeCode = message.exchangeCode;
                    exchange.state = message.state;

                    generateTabs(Object.keys(exchange.markets));
                    updateContent();
                    console.log("LobbyState", message, exchange);
                });

                connection.on("NewOrder", (order) => {
                    exchange.markets[order.market].orders.push(order);
                    console.log("NewOrder", order, exchange);
                });

                connection.on("DeletedOrder", (orderID) => {
                    console.log("DeletedOrder", orderID);
                    //delete orders[orderID];
                    //refreshExchange();
                });

                connection.on("NewParticipant", (user) => {
                    exchange.participants.push(user);
                    console.log("NewParticipant", user, exchange);
                });

                function updateOrRemove(id, quantity) {
                    //orders[id]["quantity"] += quantity;
                    //if (orders[id]["quantity"] == 0) {
                    //    delete orders[id];
                    //}
                }

                connection.on("OrderReceived", (orderList) => { // TODO it seems like this route never runs
                    console.log("OrderReceived", orderList);
                    //transactions.push(formatTransaction(transactionEvent));

                    //updateOrRemove(
                    //    transactionEvent["buyerOrderId"],
                    //    -transactionEvent["quantity"],
                    //);
                    //updateOrRemove(
                    //    transactionEvent["sellerOrderId"],
                    //    transactionEvent["quantity"],
                    //);
                    //refreshExchange();
                });

                connection.on("ClosingPrices", (closingPrices) => {
                    console.log("ClosingPrices", closingPrices);
                });

                return [connection, start];
            }

            // joinExchange needs to be run once on load to set your name and join
            // just a button to join 
            function joinExchange(name) {
                connection.invoke("JoinExchange", name).catch((err) => {
                    console.error(err.toString());
                });
            }

            // On load, checks if a jwt token is present in cookies
            // If not, redirect to login page
            if (document.cookie.indexOf("jwt") == -1) {
                window.location.href = "login.html";
            }
            const jwt = document.cookie
                .split(";")
                .find((c) => c.trim().startsWith("jwt="))
                .split("=")[1];

            // Connect to the SignalR hub
            const [connection, start] = bindConnection(jwt);
            start()
            
        </script>
    </body>
</html>
